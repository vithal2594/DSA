üìò HASHCODE() IN JAVA ‚Äì COMPLETE GUIDE
============================================================

1Ô∏è‚É£ WHAT IS hashCode() IN JAVA
------------------------------------------------------------
The `hashCode()` method in Java returns an integer hash value representing the object.
Defined in the `Object` class:

public class Object {
    public native int hashCode();
}

üß† It is used by hash-based collections (HashMap, HashSet, Hashtable)
to determine an object‚Äôs storage bucket.

============================================================

2Ô∏è‚É£ PURPOSE OF hashCode()
------------------------------------------------------------
- Provides a numeric fingerprint (hash) of an object.
- Used to store and retrieve data efficiently.
- Speeds up searching and comparison operations.
- Works alongside equals() in hash-based structures.

============================================================

3Ô∏è‚É£ INTERNAL WORKING (SIMPLIFIED)
------------------------------------------------------------
1. Collection calls hashCode() ‚Üí gets integer hash.
2. Converts hash ‚Üí bucket index.
3. If bucket already has entries ‚Üí calls equals() for verification.
4. If equals() ‚Üí true ‚Üí duplicate ignored.
5. Else ‚Üí new entry added.

============================================================

4Ô∏è‚É£ DEFAULT BEHAVIOR
------------------------------------------------------------
By default, hashCode() returns a value derived from the memory address.

Example:
Object obj = new Object();
System.out.println(obj.hashCode()); // e.g., 356573597

Different objects ‚Üí different hash codes,
even if they have same content.

============================================================

5Ô∏è‚É£ WHY OVERRIDE hashCode()
------------------------------------------------------------
If you override equals(), you must override hashCode().

Otherwise, equal objects may go into different buckets,
causing collections like HashSet or HashMap to malfunction.

‚ùå Bad Example:
------------------------------------------------------------
class Person {
    int id; String name;
    Person(int id, String name) { this.id = id; this.name = name; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person p = (Person) o;
        return id == p.id && name.equals(p.name);
    }
}

public class Main {
    public static void main(String[] args) {
        HashSet<Person> set = new HashSet<>();
        set.add(new Person(1, "A"));
        set.add(new Person(1, "A"));
        System.out.println(set.size()); // ‚ùå Output: 2
    }
}

============================================================

6Ô∏è‚É£ PROPER OVERRIDING OF hashCode()
------------------------------------------------------------
‚úÖ Correct Example:
------------------------------------------------------------
import java.util.*;

class Person {
    int id; String name;
    Person(int id, String name) { this.id = id; this.name = name; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person p = (Person) o;
        return id == p.id && Objects.equals(name, p.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
}

public class Main {
    public static void main(String[] args) {
        HashSet<Person> set = new HashSet<>();
        set.add(new Person(1, "A"));
        set.add(new Person(1, "A"));
        System.out.println(set.size()); // ‚úÖ Output: 1
    }
}

============================================================

7Ô∏è‚É£ THE hashCode() AND equals() CONTRACT
------------------------------------------------------------
| RULE | DESCRIPTION |
|------|--------------|
| Rule 1 | If equals() returns true ‚Üí hashCode() must be same |
| Rule 2 | Same hash code doesn‚Äôt guarantee equality |
| Rule 3 | hashCode() must be consistent during runtime |
| Rule 4 | Unequal objects should aim for different hash codes |

============================================================

8Ô∏è‚É£ HOW HASHMAP USES hashCode()
------------------------------------------------------------
Map<String, String> map = new HashMap<>();
map.put("Key", "Value");

1Ô∏è‚É£ Compute hashCode() of "Key"
2Ô∏è‚É£ Convert hash ‚Üí bucket index
3Ô∏è‚É£ If bucket empty ‚Üí add entry
4Ô∏è‚É£ Else compare with equals()
5Ô∏è‚É£ If equals() true ‚Üí update value, else ‚Üí add new node

============================================================

9Ô∏è‚É£ GENERATING HASHCODE MANUALLY
------------------------------------------------------------
@Override
public int hashCode() {
    int result = 17; // arbitrary seed
    result = 31 * result + id;
    result = 31 * result + (name == null ? 0 : name.hashCode());
    return result;
}
üí° The multiplier 31 spreads hash values evenly.

============================================================

üîü INTERNAL HASHCODE FOR STRINGS
------------------------------------------------------------
String class overrides hashCode() as:
------------------------------------------------------------
@Override
public int hashCode() {
    int h = 0;
    for (int i = 0; i < value.length; i++) {
        h = 31 * h + value[i];
    }
    return h;
}

Example:
System.out.println("ABC".hashCode()); // 64578
System.out.println("ACB".hashCode()); // Different hash

============================================================

11Ô∏è‚É£ COLLISIONS
------------------------------------------------------------
Two different objects can have same hash code.
When that happens ‚Üí Java stores them in same bucket.
equals() helps differentiate them.

Example:
System.out.println("FB".hashCode()); // 2236
System.out.println("Ea".hashCode()); // 2236

Different strings, same hash (collision).

============================================================

12Ô∏è‚É£ IMPORTANCE IN COLLECTIONS
------------------------------------------------------------
| COLLECTION | USE OF hashCode() |
|-------------|------------------|
| HashSet | Avoid duplicate entries |
| HashMap | Determines key location |
| HashTable | Similar to HashMap but synchronized |

============================================================

13Ô∏è‚É£ BEST PRACTICES
------------------------------------------------------------
‚úÖ Always override hashCode() with equals()
‚úÖ Use immutable fields in hash computation
‚úÖ Use Objects.hash() or the 31 * pattern
‚úÖ Avoid using mutable fields
‚úÖ Maintain hash consistency
‚úÖ Avoid expensive operations in hashCode()
‚úÖ Test using HashSet or HashMap

============================================================

14Ô∏è‚É£ COMMON MISTAKES
------------------------------------------------------------
‚ùå Overriding equals() but not hashCode()
‚ùå Using mutable objects as keys
‚ùå Assuming unique hashCode() means unique object
‚ùå Using variable data fields in hashCode()
‚ùå Violating hash-equals contract

============================================================

15Ô∏è‚É£ REAL-WORLD ANALOGY
------------------------------------------------------------
Think of hashCode() as a "mailbox number":
- Many people may live in same building (same hash)
- equals() tells who exactly the person is (specific ID)

============================================================

16Ô∏è‚É£ COMBINED equals() & hashCode() EXAMPLE
------------------------------------------------------------
import java.util.Objects;
import java.util.HashSet;

class Book {
    String isbn;
    String title;

    Book(String isbn, String title) {
        this.isbn = isbn;
        this.title = title;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Book)) return false;
        Book b = (Book) o;
        return Objects.equals(isbn, b.isbn);
    }

    @Override
    public int hashCode() {
        return Objects.hash(isbn);
    }
}

public class Main {
    public static void main(String[] args) {
        HashSet<Book> books = new HashSet<>();
        books.add(new Book("123", "Java Basics"));
        books.add(new Book("123", "Java Basics"));
        System.out.println(books.size()); // ‚úÖ Output: 1
    }
}

============================================================

17Ô∏è‚É£ WHEN NOT TO OVERRIDE hashCode()
------------------------------------------------------------
- For immutable system classes like Thread, Class
- When you only need reference equality
- If objects are never used in hash-based collections

============================================================

18Ô∏è‚É£ QUICK COMPARISON: equals() vs hashCode()
------------------------------------------------------------
| ASPECT | equals() | hashCode() |
|---------|-----------|------------|
| Purpose | Logical equality | Bucket indexing |
| Return Type | boolean | int |
| Default Behavior | Reference equality | Memory address-based |
| Can Override | ‚úÖ Yes | ‚úÖ Yes |
| Used In | All objects | Hash-based collections |
| Contract | Must align with hashCode() | Must align with equals() |

============================================================

19Ô∏è‚É£ SUMMARY
------------------------------------------------------------
‚úÖ hashCode() returns an integer representing an object.
‚úÖ Used in hash-based data structures (HashSet, HashMap).
‚úÖ Equal objects must have same hashCode().
‚úÖ Unequal objects should try for unique hash codes.
‚úÖ Collisions handled using equals().
‚úÖ Crucial for performance and correctness of hash collections.

============================================================
