ðŸ“˜ Encapsulation in Java - Complete Guide
==================================================

1. What is Encapsulation?
--------------------------------------------------
Encapsulation is one of the four main pillars of Object-Oriented Programming (OOP).
It refers to the concept of **wrapping data (variables)** and **methods (functions)** 
into a single unit (class) and **restricting direct access** to the internal data.

ðŸ‘‰ Simple Definition:
Encapsulation = Data Hiding + Controlled Access

Example:
--------------------------------------------------
public class Student {
    // Private fields - hidden from outside classes
    private String name;
    private int age;

    // Public getter and setter methods for controlled access
    public String getName() {
        return name;
    }

    public void setName(String name) {
        // Validation logic
        if (name != null && !name.isEmpty())
            this.name = name;
        else
            System.out.println("Invalid name!");
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        // Validation logic
        if (age > 0)
            this.age = age;
        else
            System.out.println("Invalid age!");
    }
}

public class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("Alice");    // Valid
        s.setAge(21);          // Valid
        System.out.println(s.getName() + " is " + s.getAge() + " years old.");
    }
}

Pointers:
1. The fields are private (data hidden).
2. Public methods provide controlled access.
3. Validation ensures correct data entry.
4. Other classes canâ€™t directly modify private fields.
5. Maintains integrity of data.
6. Achieved via access modifiers and getter/setter methods.

--------------------------------------------------

2. Key Concepts of Encapsulation
--------------------------------------------------
1. **Data Hiding:** Restricting direct access to class data using private fields.
2. **Controlled Access:** Accessing data only through public methods.
3. **Access Modifiers:** Define visibility of class members.
4. **Data Validation:** Ensuring correctness of data before assignment.
5. **Security:** Protects sensitive information.
6. **Modularity:** Each class acts as a self-contained unit.
7. **Reusability:** Encapsulated classes can be reused safely.
8. **Maintenance:** Easier updates without affecting other classes.

--------------------------------------------------

3. Example of Encapsulation (With Comments)
--------------------------------------------------
public class Employee {
    // Private fields - Data hiding
    private String name;
    private double salary;

    // Constructor
    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    // Getter for name
    public String getName() {
        return name;
    }

    // Setter for name with validation
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty())
            this.name = name;
        else
            System.out.println("Invalid name!");
    }

    // Getter for salary
    public double getSalary() {
        return salary;
    }

    // Setter for salary with validation
    public void setSalary(double salary) {
        if (salary > 0)
            this.salary = salary;
        else
            System.out.println("Salary must be positive!");
    }

    // Method to display employee details
    public void display() {
        System.out.println("Employee: " + name + " | Salary: " + salary);
    }
}

public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee("John", 50000);
        emp.display();

        emp.setSalary(60000); // Valid
        emp.setSalary(-1000); // Invalid
        emp.display();
    }
}

Explanation:
- Private fields ensure data hiding.
- Public setters/getters provide controlled access.
- Validation logic prevents invalid data assignment.
- Class acts as a secure, self-contained data capsule.

20 Pointers:
1. Combines data and methods.
2. Achieved using private fields + getters/setters.
3. Protects internal state from unauthorized access.
4. Allows validation before modification.
5. Enhances data integrity.
6. Improves maintainability.
7. Promotes reusability.
8. Supports modular design.
9. Prevents misuse of sensitive data.
10. Reduces complexity.
11. Enhances flexibility in implementation.
12. Encourages loose coupling.
13. Supports secure application design.
14. Is part of every good OOP architecture.
15. Allows better debugging and testing.
16. Makes future updates easier.
17. Avoids global variable misuse.
18. Increases clarity in class responsibilities.
19. Can restrict read/write access separately.
20. Foundation for immutability in Java.

--------------------------------------------------

4. Key Points About Encapsulation (10â€“15 points)
--------------------------------------------------
1. Data members should always be private.
2. Public methods provide controlled access.
3. Achieved through getters and setters.
4. Improves data security and consistency.
5. Protects object integrity.
6. Encourages modular, flexible design.
7. Provides abstraction at data level.
8. Prevents accidental data modification.
9. Reduces interdependency.
10. Simplifies future maintenance.
11. Supports object reusability.
12. Improves debugging efficiency.
13. Promotes cleaner code architecture.
14. Forms base for object-oriented design.
15. Often used in frameworks like Spring, Hibernate.

--------------------------------------------------

5. Access Modifiers and Encapsulation
--------------------------------------------------
Access modifiers define the **visibility** of class members.

Types:
1. **private** â€“ Accessible only within the same class.
2. **default (no modifier)** â€“ Accessible within the same package.
3. **protected** â€“ Accessible within same package and subclasses.
4. **public** â€“ Accessible from anywhere.

Example:
--------------------------------------------------
public class Demo {
    private int privateVar = 10;   // Accessible only inside class
    int defaultVar = 20;           // Accessible inside package
    protected int protectedVar = 30;// Accessible in subclass
    public int publicVar = 40;     // Accessible everywhere

    public void showVars() {
        System.out.println("All variables accessed inside class.");
    }
}

public class Main {
    public static void main(String[] args) {
        Demo d = new Demo();
        // System.out.println(d.privateVar); // âŒ Error
        System.out.println(d.publicVar);      // âœ… Accessible
    }
}

7 Points for Each Modifier:
**Private**
1. Most restrictive.
2. Used for encapsulation.
3. Data hidden from other classes.
4. Accessible only inside same class.
5. Used for sensitive data.
6. Common for fields.
7. Accessed using public methods.

**Default**
1. Visible within same package.
2. No explicit keyword required.
3. Used for package-level communication.
4. Not visible outside package.
5. Moderate restriction.
6. Often used for helper classes.
7. Supports modular design.

**Protected**
1. Accessible in same package and subclasses.
2. Useful for inheritance.
3. Balances security and reusability.
4. Not accessible by unrelated classes.
5. Often used for parent-child relationships.
6. Common in frameworks.
7. Used in superclass members.

**Public**
1. Least restrictive.
2. Accessible everywhere.
3. Common for APIs.
4. Used for class methods and constants.
5. Enables code reuse.
6. Can expose behaviors safely.
7. Not recommended for sensitive data.

--------------------------------------------------

6. Example: Restricted Data Access
--------------------------------------------------
public class BankAccount {
    private double balance; // private field - hidden

    public BankAccount(double balance) {
        this.balance = balance;
    }

    // Public method for controlled read access
    public double getBalance() {
        return balance;
    }

    // Deposit method with validation
    public void deposit(double amount) {
        if (amount > 0)
            balance += amount;
        else
            System.out.println("Invalid deposit!");
    }

    // Withdraw method with validation
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance)
            balance -= amount;
        else
            System.out.println("Invalid withdrawal!");
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount acc = new BankAccount(1000);
        acc.deposit(500);
        acc.withdraw(200);
        System.out.println("Balance: " + acc.getBalance());
    }
}

Explanation:
- `balance` is private (hidden).
- Accessed through public methods only.
- Deposit and withdraw methods enforce rules.
- Prevents invalid or unsafe changes.

Pointers:
1. Demonstrates complete data hiding.
2. Access controlled by validation.
3. Improves security and consistency.
4. Prevents external modification of balance.
5. Protects sensitive information.

--------------------------------------------------

7. Advantages of Encapsulation
--------------------------------------------------
1. Improves security.
2. Protects data from unauthorized access.
3. Simplifies code maintenance.
4. Encourages modular programming.
5. Enables data validation.
6. Makes code more flexible.
7. Reduces system complexity.
8. Encourages reusability.
9. Supports abstraction.
10. Improves scalability.

--------------------------------------------------

8. Disadvantages of Encapsulation
--------------------------------------------------
1. Slightly increases code size.
2. May require extra methods.
3. Adds complexity for beginners.
4. May introduce performance overhead.
5. Overuse can reduce readability.

--------------------------------------------------

9. Rules for Proper Encapsulation
--------------------------------------------------
1. Declare fields as private.
2. Provide public getters/setters.
3. Add validation in setters.
4. Hide internal implementation.
5. Avoid exposing unnecessary fields.
6. Use appropriate access modifiers.
7. Keep class APIs clean and minimal.
8. Avoid public mutable objects.
9. Follow Java naming conventions.
10. Ensure consistent access control.

--------------------------------------------------

10. Encapsulation vs Abstraction
--------------------------------------------------
| Feature | Encapsulation | Abstraction |
|----------|----------------|--------------|
| Focus | Data hiding | Implementation hiding |
| Purpose | Protect data integrity | Simplify complexity |
| Level | Implementation level | Design level |
| Achieved By | Private fields, getters/setters | Abstract classes, interfaces |
| Example | private int balance; | abstract void start(); |
| Dependency | Supports abstraction | Built on encapsulation |
| Visibility | Controlled through access modifiers | Controlled through method exposure |

--------------------------------------------------

11. Encapsulation and Immutability
--------------------------------------------------
Encapsulation is the foundation of immutable classes.
By removing setters and making fields final, you can make the class immutable.

Example:
--------------------------------------------------
public final class Student {
    private final String name;
    private final int rollNo;

    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    public String getName() { return name; }
    public int getRollNo() { return rollNo; }
}

Explanation:
1. No setters â€” data cannot be changed.
2. Fields are private and final.
3. Class is declared final â€” cannot be extended.
4. Perfect example of secure encapsulation.

==================================================
âœ… Summary:
- Encapsulation = Data hiding + Controlled access.
- Achieved via private fields and public methods.
- Ensures data security, consistency, and modularity.
- Foundation for abstraction and immutability.
==================================================
