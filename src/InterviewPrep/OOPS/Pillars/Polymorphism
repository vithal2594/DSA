üìò POLYMORPHISM IN JAVA ‚Äì COMPLETE GUIDE
============================================================

1Ô∏è‚É£ WHAT IS POLYMORPHISM?
------------------------------------------------------------
Polymorphism means ‚Äúmany forms‚Äù. The same method or object can perform different actions depending on its context.
It enables dynamic behavior and reusability.

CODE EXAMPLE:
------------------------------------------------------------
class Animal {
    void sound() { System.out.println("Animal makes a sound"); }
}

class Dog extends Animal {
    void sound() { System.out.println("Dog barks"); }
}

class Cat extends Animal {
    void sound() { System.out.println("Cat meows"); }
}

public class Main {
    public static void main(String[] args) {
        Animal a;        // reference variable of parent
        a = new Dog();   // object of child
        a.sound();       // Dog‚Äôs version executes
        a = new Cat();   // new object assigned
        a.sound();       // Cat‚Äôs version executes
    }
}

EXPLANATION ‚Äì 10 POINTERS:
1. ‚ÄúAnimal‚Äù is parent; ‚ÄúDog‚Äù and ‚ÄúCat‚Äù extend it.
2. Parent reference variable can refer to any child object.
3. Method behavior depends on object type, not reference type.
4. The same method name (‚Äúsound‚Äù) behaves differently.
5. This is runtime polymorphism.
6. Achieved using inheritance and overriding.
7. Encourages flexible code and reusability.
8. Decouples interface from implementation.
9. Enhances code scalability.
10. Central to OOP design.

============================================================

2Ô∏è‚É£ WHY POLYMORPHISM IS IMPORTANT ‚Äì 10 POINTERS
------------------------------------------------------------
1. Enables runtime flexibility.
2. Simplifies code maintenance.
3. Reduces redundancy.
4. Supports abstraction and inheritance.
5. Allows designing generic APIs.
6. Improves readability and structure.
7. Encourages interface-based programming.
8. Core to frameworks (Spring, Hibernate).
9. Supports dynamic method dispatch.
10. Makes systems easily extendable.

============================================================

3Ô∏è‚É£ TYPES OF POLYMORPHISM IN JAVA
------------------------------------------------------------
There are two types:
A. Compile-time (Static) Polymorphism
B. Runtime (Dynamic) Polymorphism

A) COMPILE-TIME POLYMORPHISM (Method Overloading)
------------------------------------------------------------
class Calculator {
    // same method name, different parameters
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
}

public class Main {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.add(2, 3));       // calls int version
        System.out.println(c.add(2.5, 3.5));   // calls double version
        System.out.println(c.add(1, 2, 3));    // calls 3-arg version
    }
}

20 POINTERS:
1. Occurs at compile time.
2. Achieved by method overloading.
3. Same method name, different parameter list.
4. Return type may differ if parameters differ.
5. Known as static binding.
6. Increases code readability.
7. Common in mathematical or utility classes.
8. Improves performance by early binding.
9. Parameters determine which version executes.
10. Cannot depend on return type alone.
11. Compiler decides which method to call.
12. Example of polymorphism without inheritance.
13. Used in constructors and operators.
14. Overloaded methods can coexist peacefully.
15. Default arguments not allowed (unlike C++).
16. Safer and faster than runtime polymorphism.
17. Cannot be achieved through overriding.
18. Example: System.out.println() is overloaded.
19. Each version performs related tasks differently.
20. Ideal for compile-time decision making.

------------------------------------------------------------
B) RUNTIME POLYMORPHISM (Method Overriding)
------------------------------------------------------------
class Vehicle {
    void run() { System.out.println("Vehicle is running"); }
}
class Bike extends Vehicle {
    void run() { System.out.println("Bike is running safely"); }
}
class Car extends Vehicle {
    void run() { System.out.println("Car is driving smoothly"); }
}
public class Main {
    public static void main(String[] args) {
        Vehicle v1 = new Bike();
        Vehicle v2 = new Car();
        v1.run();  // Bike version
        v2.run();  // Car version
    }
}

20 POINTERS:
1. Achieved through method overriding.
2. Decided at runtime, not compile time.
3. Requires inheritance.
4. Same method name, same parameters.
5. Different behavior per subclass.
6. Parent reference can refer to any child.
7. Actual method depends on object type.
8. Uses @Override annotation for clarity.
9. Enables dynamic method dispatch.
10. Central to Java‚Äôs OOP design.
11. Helps create flexible architecture.
12. Used widely in interfaces and abstract classes.
13. Example of dynamic binding.
14. Reduces coupling.
15. Improves extensibility.
16. Enables polymorphic arrays and collections.
17. Static and final methods cannot be overridden.
18. Constructors can‚Äôt be overridden.
19. Implemented at JVM level via v-tables.
20. Fundamental for framework extensibility.

============================================================

4Ô∏è‚É£ KEY CONCEPTS IN POLYMORPHISM ‚Äì POINTERS
------------------------------------------------------------
1. Method Overloading ‚Äì compile-time polymorphism.
2. Method Overriding ‚Äì runtime polymorphism.
3. Upcasting ‚Äì parent reference, child object.
4. Dynamic Binding ‚Äì linking call to object at runtime.
5. Late Binding ‚Äì another term for runtime polymorphism.
6. Static Binding ‚Äì compile-time method resolution.
7. Interface Polymorphism ‚Äì multiple implementations same contract.
8. Abstract Polymorphism ‚Äì achieved via abstract classes.
9. Object Behavior Polymorphism ‚Äì object acts differently by class.
10. Generic Polymorphism ‚Äì using generics for flexible typing.

============================================================

5Ô∏è‚É£ UPCASTING AND DOWNCASTING
------------------------------------------------------------
class Animal { void eat() { System.out.println("Animal eats"); } }
class Dog extends Animal { void bark() { System.out.println("Dog barks"); } }

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();  // Upcasting ‚Äì safe
        a.eat();
        // a.bark();  // not allowed directly

        Dog d = (Dog) a;       // Downcasting ‚Äì explicit
        d.bark();
    }
}

POINTERS:
1. Upcasting is implicit and safe.
2. Downcasting explicit and risky.
3. ClassCastException possible if invalid.
4. Enables polymorphism through parent references.
5. Common in collections.
6. Promotes flexibility.
7. Required for accessing subclass-specific members.

============================================================

6Ô∏è‚É£ ABSTRACT CLASS & POLYMORPHISM EXAMPLE
------------------------------------------------------------
abstract class Shape {
    abstract void draw();
}
class Circle extends Shape {
    void draw() { System.out.println("Drawing Circle"); }
}
class Square extends Shape {
    void draw() { System.out.println("Drawing Square"); }
}
public class Main {
    public static void main(String[] args) {
        Shape s;
        s = new Circle();
        s.draw();
        s = new Square();
        s.draw();
    }
}

15 POINTERS:
1. Abstract classes cannot be instantiated.
2. Child must implement abstract methods.
3. Enables runtime polymorphism.
4. Reference type is abstract class.
5. Decides method execution dynamically.
6. Promotes code reuse via base abstraction.
7. Allows partial implementation.
8. Used in templates and frameworks.
9. Combines abstraction + polymorphism.
10. Helps model real-world hierarchies.
11. Each subclass provides its own behavior.
12. Base class defines the ‚Äúwhat‚Äù, subclass defines the ‚Äúhow‚Äù.
13. Supports runtime binding.
14. Reduces code duplication.
15. Used in strategy and factory patterns.

============================================================

7Ô∏è‚É£ POLYMORPHISM IN INTERFACES
------------------------------------------------------------
interface Payment {
    void pay();
}
class CreditCard implements Payment {
    public void pay() { System.out.println("Paid via Credit Card"); }
}
class UPI implements Payment {
    public void pay() { System.out.println("Paid via UPI"); }
}
public class Main {
    public static void main(String[] args) {
        Payment p = new CreditCard();
        p.pay();
        p = new UPI();
        p.pay();
    }
}

15 POINTERS:
1. Interface defines a contract.
2. Different classes can implement it differently.
3. Achieves loose coupling.
4. Enables runtime polymorphism.
5. Encourages plug-and-play behavior.
6. Common in real-world APIs.
7. Parent reference variable (interface type) can hold any implementing object.
8. Supports multiple inheritance.
9. Simplifies dependency injection.
10. Makes testing easier.
11. Promotes abstraction and flexibility.
12. Used heavily in Spring Framework.
13. Allows replacing implementations easily.
14. Enables layered architecture.
15. Core concept behind Java polymorphism.

============================================================

8Ô∏è‚É£ REAL-WORLD EXAMPLE
------------------------------------------------------------
class Employee {
    void work() { System.out.println("Employee working"); }
}
class Manager extends Employee {
    void work() { System.out.println("Manager managing team"); }
}
class Developer extends Employee {
    void work() { System.out.println("Developer writing code"); }
}
public class Main {
    public static void main(String[] args) {
        Employee e1 = new Manager();
        Employee e2 = new Developer();
        e1.work();
        e2.work();
    }
}

7 POINTERS:
1. Both Manager and Developer are Employees.
2. Each overrides ‚Äúwork()‚Äù.
3. Parent reference, different behaviors.
4. Same interface, many forms.
5. Simplifies extending new roles later.
6. Demonstrates runtime polymorphism.
7. Realistic workplace hierarchy model.

============================================================

9Ô∏è‚É£ ADVANTAGES OF POLYMORPHISM
------------------------------------------------------------
1. Increases flexibility.
2. Enables runtime decisions.
3. Improves code maintenance.
4. Reduces redundancy.
5. Encourages interface-based programming.
6. Supports extensibility.
7. Simplifies large codebases.
8. Encourages clean architecture.
9. Central to design patterns.
10. Promotes code reusability.

============================================================

üîü DISADVANTAGES OF POLYMORPHISM
------------------------------------------------------------
1. Slight runtime overhead.
2. More complex debugging.
3. May obscure true behavior.
4. Can be overused or misused.
5. Adds layer of abstraction.
6. Requires inheritance knowledge.
7. Harder performance optimization.

============================================================

11Ô∏è‚É£ RULES OF POLYMORPHISM
------------------------------------------------------------
1. Must involve inheritance or interface.
2. Method signature must match exactly.
3. Static, final, and private methods are not polymorphic.
4. Return type must be covariant.
5. Uses dynamic method dispatch at runtime.
6. Overloading is compile-time; overriding is runtime.
7. Object type decides the method executed.
8. Parent reference can refer to child object.
9. Must use @Override annotation for clarity.
10. Constructors are not polymorphic.

============================================================

12Ô∏è‚É£ POLYMORPHISM VS INHERITANCE
------------------------------------------------------------
| FEATURE | INHERITANCE | POLYMORPHISM |
|----------|--------------|--------------|
| Definition | Code reuse via parent-child | Same method, many forms |
| Type | Structural | Behavioral |
| Binding | Compile-time | Runtime |
| Relationship | IS-A | Behaves like |
| Focus | Reusing code | Redefining behavior |
| Example | Dog extends Animal | Animal a = new Dog(); a.sound(); |

============================================================
‚úÖ SUMMARY
------------------------------------------------------------
- Polymorphism enables one interface, many behaviors.
- Achieved via overloading (compile-time) and overriding (runtime).
- Core principle for extensible and maintainable OOP design.
- Powers frameworks, abstraction layers, and design patterns.
============================================================
