üìò Abstraction in Java - Complete Guide
==================================================

1. What is Abstraction?
--------------------------------------------------
Abstraction in Java is the process of hiding internal implementation details
and showing only the essential features of an object.

üëâ In simple terms: Focus on "what" an object does instead of "how" it does it.

Example:
--------------------------------------------------
abstract class Car {
    abstract void start(); // Hides how starting happens, shows only that car can start
}

class Tesla extends Car {
    void start() {
        System.out.println("Tesla starts with voice command.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Tesla();
        myCar.start(); // Output: Tesla starts with voice command.
    }
}

Key Points:
1. Hides complexity and internal details.
2. Focuses on essential features.
3. Increases flexibility and security.
4. Provides a clear separation between interface and implementation.
5. Achieved using Abstract Classes and Interfaces.

--------------------------------------------------

2. Why Abstraction is Important (10 Points)
--------------------------------------------------
1. Simplifies complex systems.
2. Improves maintainability of code.
3. Enhances security by hiding internal details.
4. Allows developers to focus on high-level logic.
5. Encourages reusability and modular design.
6. Provides flexibility for implementation changes.
7. Reduces code duplication.
8. Helps achieve loose coupling between components.
9. Makes debugging and testing easier.
10. Forms the foundation of OOP design patterns.

--------------------------------------------------

3. How Abstraction is Achieved in Java
--------------------------------------------------
Java achieves abstraction in two ways:
1. Using Abstract Classes
2. Using Interfaces

Example using Abstract Class:
--------------------------------------------------
abstract class Vehicle {
    abstract void start(); // abstract method
    void fuel() { // concrete method
        System.out.println("Fuel added");
    }
}

class Bike extends Vehicle {
    void start() {
        System.out.println("Bike starts with a kick!");
    }
}

Example using Interface:
--------------------------------------------------
interface Machine {
    void powerOn();
}

class WashingMachine implements Machine {
    public void powerOn() {
        System.out.println("Machine powered on!");
    }
}

10 Key Points:
1. Abstract classes achieve partial abstraction (0‚Äì100%).
2. Interfaces achieve full abstraction.
3. Abstract classes can have constructors.
4. Interfaces cannot have constructors.
5. Interfaces support multiple inheritance.
6. Abstract classes use 'extends'; interfaces use 'implements'.
7. Both define a contract for subclasses.
8. Interfaces can have default/static methods (Java 8+).
9. Abstract classes can have instance variables.
10. Both improve flexibility and modularity.

--------------------------------------------------

4. Abstract Classes in Java
--------------------------------------------------
Definition:
An abstract class in Java is declared with the 'abstract' keyword.
It can contain both abstract (no body) and non-abstract (with body) methods.

Code Example:
--------------------------------------------------
abstract class Shape {
    abstract void draw(); // abstract method

    void color() { // concrete method
        System.out.println("Shape has color");
    }
}

class Circle extends Shape {
    void draw() {
        System.out.println("Drawing a Circle");
    }
}

20 Key Points:
1. Cannot be instantiated directly.
2. Can contain abstract and concrete methods.
3. Used when subclasses share common behavior.
4. Helps define a template for subclasses.
5. Abstract method must be implemented by child class.
6. Can have constructors.
7. Can have static methods.
8. Can have final methods (cannot be overridden).
9. Can include instance and static variables.
10. Supports inheritance and polymorphism.
11. Abstract class can extend another abstract class.
12. Can implement interfaces.
13. Abstract methods cannot be static.
14. Cannot use 'abstract' with 'final'.
15. Abstract class can have access modifiers.
16. Can define common reusable logic.
17. Improves readability of large systems.
18. Provides partial abstraction.
19. Better for hierarchical designs.
20. Real-world example: Vehicle, Shape, Employee hierarchy.

--------------------------------------------------

5. Interface in Java
--------------------------------------------------
Definition:
An interface is a collection of abstract methods that define a contract
for classes to implement. Interfaces achieve 100% abstraction.

Code Example:
--------------------------------------------------
interface Animal {
    void eat(); // abstract by default
    void sleep(); // abstract by default

    default void sound() { // Java 8 feature
        System.out.println("Animals make sounds");
    }

    static void info() {
        System.out.println("All animals have life");
    }
}

class Dog implements Animal {
    public void eat() {
        System.out.println("Dog eats bones");
    }
    public void sleep() {
        System.out.println("Dog sleeps in kennel");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.eat();
        dog.sleep();
        dog.sound(); // Default method
        Animal.info(); // Static method
    }
}

20 Key Points:
1. Achieves 100% abstraction.
2. Cannot have constructors.
3. Cannot hold instance variables.
4. Methods are public and abstract by default.
5. Variables are public, static, and final by default.
6. Supports multiple inheritance.
7. Uses 'implements' keyword.
8. Can have default, static, and private methods (Java 9+).
9. Interface methods must be implemented by subclasses.
10. Used to define a contract or capability.
11. Cannot be instantiated.
12. Can extend other interfaces.
13. Promotes loose coupling.
14. Useful for service-based designs.
15. Interface references can hold implementing class objects.
16. Can be used with lambda expressions (Functional Interface).
17. Encourages API standardization.
18. Helps implement dependency injection.
19. Increases reusability and modularity.
20. Preferred for defining behavior, not data.

--------------------------------------------------

6. Difference Between Abstract Class and Interface
--------------------------------------------------
| Feature | Abstract Class | Interface |
|----------|----------------|------------|
| Keyword | abstract | interface |
| Inheritance | extends | implements |
| Constructors | Allowed | Not allowed |
| Variables | Can be instance/static | public static final only |
| Method Type | Both abstract & concrete | Mostly abstract (can have default/static) |
| Multiple Inheritance | Not supported | Supported |
| Access Modifiers | All types allowed | public only |
| Abstraction Level | 0‚Äì100% | 100% |
| Real Use | Shared base with logic | Common behavior contract |
| Example | Vehicle, Shape | Runnable, Comparable |

--------------------------------------------------

7. Abstract Class with Constructor and Fields Example
--------------------------------------------------
abstract class Shape {
    String color;

    Shape(String color) { // Constructor
        this.color = color;
    }

    abstract double area(); // abstract method

    void displayColor() {
        System.out.println("Color: " + color);
    }
}

class Circle extends Shape {
    double radius;

    Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    double area() {
        return Math.PI * radius * radius;
    }
}

public class Main {
    public static void main(String[] args) {
        Shape s = new Circle("Red", 5.0);
        s.displayColor();
        System.out.println("Area: " + s.area());
    }
}

Key Points:
1. Abstract class can have constructors.
2. Constructors are used to initialize fields.
3. Child class calls parent constructor using super().
4. Abstract method must be implemented by subclass.
5. Abstract class can have instance variables.
6. Supports polymorphism.
7. Provides partial abstraction.
8. Promotes reusability.
9. Used as a base class template.
10. Cannot be instantiated directly.

--------------------------------------------------

8. Real-World Analogy of Abstraction
--------------------------------------------------
1. A car driver uses steering and pedals without knowing internal mechanisms.
2. A smartphone user interacts via icons, not internal circuits.
3. An ATM provides withdrawal and balance features without exposing backend logic.
4. Remote control hides the TV's internal wiring.
5. Database APIs hide SQL complexities.

--------------------------------------------------

9. Advantages of Abstraction
--------------------------------------------------
1. Simplifies complex systems.
2. Improves maintainability.
3. Enhances code reusability.
4. Increases security.
5. Makes code easier to read.
6. Enables loose coupling.
7. Promotes modular architecture.
8. Improves flexibility.
9. Reduces redundancy.
10. Aids in scalable designs.

--------------------------------------------------

10. Disadvantages of Abstraction
--------------------------------------------------
1. Adds design complexity.
2. May reduce transparency.
3. Overhead of abstract hierarchies.
4. Harder debugging due to hidden details.
5. Too much abstraction may confuse beginners.
6. Slight runtime cost (polymorphism).
7. Requires good design discipline.

--------------------------------------------------

11. Key Rules of Abstraction in Java
--------------------------------------------------
1. Abstract classes cannot be instantiated.
2. Must implement all abstract methods in child classes.
3. Abstract classes can have constructors, fields, static methods.
4. Abstract methods cannot be static or final.
5. Interfaces cannot have instance fields.
6. A class can extend one abstract class.
7. A class can implement multiple interfaces.
8. Abstract classes use extends; interfaces use implements.
9. Abstract methods define ‚Äúwhat‚Äù to do.
10. Subclasses define ‚Äúhow‚Äù to do.

--------------------------------------------------

12. Abstraction vs Encapsulation
--------------------------------------------------
| Feature | Abstraction | Encapsulation |
|----------|--------------|---------------|
| Focus | Hides implementation details | Hides data using access modifiers |
| Purpose | Simplify complexity | Protect data integrity |
| Level | Design level | Implementation level |
| Achieved By | Abstract classes, Interfaces | Getters/Setters |
| Example | abstract void start() | private int speed; public void setSpeed() |
| Relation | Works with Encapsulation | Supports Abstraction |

==================================================
‚úÖ Summary:
- Abstraction = Focus on "what", not "how".
- Achieved via Abstract Classes and Interfaces.
- Hides complexity, enhances security, and improves flexibility.
- Essential for clean OOP design.
==================================================
"""